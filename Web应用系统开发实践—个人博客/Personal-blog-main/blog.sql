/*
 Navicat Premium Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 50562
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50562
 File Encoding         : 65001

 Date: 08/09/2022 01:24:22
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `first_picture` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `flag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `views` int(11) NULL DEFAULT NULL,
  `appreciation` int(11) NOT NULL DEFAULT 0,
  `share_statement` int(11) NOT NULL DEFAULT 0,
  `commentabled` int(11) NOT NULL DEFAULT 0,
  `published` int(11) NOT NULL DEFAULT 0,
  `recommend` int(11) NOT NULL DEFAULT 0,
  `create_time` datetime NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  `type_id` bigint(20) NULL DEFAULT NULL,
  `user_id` bigint(20) NULL DEFAULT NULL,
  `description` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `tag_ids` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES (1, 'maven中静态资源的过滤', '# maven中静态资源的过滤\r\n\r\npom.xml文件中加入下面配置\r\n\r\n### 可以过滤java和resources文件夹里面所有的的.properties和.xml文件\r\n**directory：指定资源所在的目录，目录的路径是相对于pom.xml文件的\r\nincludes：指定要包含哪些文件**\r\n**filtering标签中：false表示不过滤，true表示过滤**\r\n\r\n```java\r\n    <build>\r\n        <resources>\r\n            <resource>\r\n                <directory>src/main/java</directory>\r\n                <includes>\r\n                    <include>**/*.properties</include>\r\n                    <include>**/*.xml</include>\r\n                </includes>\r\n                <filtering>false</filtering>\r\n            </resource>\r\n            <resource>\r\n                <directory>src/main/resources</directory>\r\n                <includes>\r\n                    <include>**/*.properties</include>\r\n                    <include>**/*.xml</include>\r\n                </includes>\r\n                <filtering>false</filtering>\r\n            </resource>\r\n        </resources>\r\n    </build>\r\n```\r\n', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1584367888190&di=7855ff350e759b4b3de8c614978673b4&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201612%2F07%2F20161207154722_Cmce5.thumb.400_0.gif', '原创', 0, 1, 1, 1, 1, 1, '2022-09-06 08:25:47', '2022-09-06 08:25:47', 1, 1, 'pom.xml文件中加入下面配置\r\n可以过滤java和resources文件夹里面所有的的.properties和.xml文件', '4');
INSERT INTO `t_blog` VALUES (2, '使用System.out.format()格式化输出', '#### JDK5.0允许java像C语言那样直接用printf()方法来格式化输出\r\n####  System.out.format()功能与printf()一样，可以使用%d,%f等参数。\r\n使用System.out.format()完成**左对齐，补0，千位分隔符，小数点位数，本地化表达**\r\n```java\r\npublic class TestNumber {\r\n   \r\n    public static void main(String[] args) {\r\n        int year = 2020;\r\n        //左对齐，补0，千位分隔符，小数点位数，本地化表达\r\n        \r\n      //直接打印数字\r\n        System.out.println(year);\r\n          \r\n        //直接打印数字\r\n        System.out.format(\"%d%n\",year);\r\n        //总长度是8,默认右对齐\r\n        System.out.format(\"%8d%n\",year);\r\n        //总长度是8,左对齐\r\n        System.out.format(\"%-8d%n\",year);\r\n        //总长度是8,不够补0\r\n        System.out.format(\"%08d%n\",year);\r\n        //千位分隔符\r\n        System.out.format(\"%,8d%n\",year*10000);\r\n  \r\n        //保留5位小数\r\n        System.out.format(\"%.5f%n\",Math.PI);\r\n          \r\n        //不同国家的千位分隔符\r\n        System.out.format(Locale.FRANCE,\"%,.2f%n\",Math.PI*10000);\r\n        System.out.format(Locale.US,\"%,.2f%n\",Math.PI*10000);\r\n        System.out.format(Locale.UK,\"%,.2f%n\",Math.PI*10000);\r\n          \r\n    }\r\n}\r\n```\r\n输出结果：\r\n\r\n```java\r\n2020\r\n2020\r\n    2020\r\n2020    \r\n00002020\r\n20,200,000\r\n3.14159\r\n31?415,93\r\n31,415.93\r\n31,415.93\r\n```\r\n', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1584368822685&di=19855856bbd158b52926a49b51e876c0&imgtype=0&src=http%3A%2F%2Fwx2.sinaimg.cn%2Fcrop.0.4.1280.711%2F70745653ly1fvuflwe10zj20zk0k0n06.jpg', '原创', 0, 1, 1, 1, 1, 1, '2022-09-06 13:42:14', '2022-09-06 13:42:14', 1, 1, 'JDK5.0允许java像C语言那样直接用printf()方法来格式化输出\r\nSystem.out.format()功能与printf()一样，可以使用%d,%f等参数。\r\n\r\n使用System.out.format()完成左对齐，补0，千位分隔符，小数点位数，本地化表达', '7');
INSERT INTO `t_blog` VALUES (3, 'Springboot中PageHelper 分页查询使用方法', '### 一：导入依赖\r\n\r\n```java\r\n<dependency>\r\n	<groupId>com.github.pagehelper</groupId>\r\n	<artifactId>pagehelper-spring-boot-starter</artifactId>\r\n	<version>1.2.13</version>\r\n</dependency>\r\n```\r\n### 二：配置yml文件中PageHelper的属性\r\n\r\n```java\r\npagehelper:                #分页插件\r\n  helper-dialect: mysql\r\n  reasonable: true\r\n  support-methods-arguments: true\r\n  params:\r\n```\r\n### 三：在controller类中使用，\r\n##### 1.在查询方法上调用PageHelper.startPage()方法，设置分页的页数和每页信息数，\r\n##### 2.将查询出来的结果集用PageInfo的构造函数初始化为一个分页结果对象\r\n##### 3.将分页结果对象存入model，返回前端页面\r\n```java\r\n@GetMapping(\"/types\")\r\npublic String types(@RequestParam(required = false,defaultValue = \"1\",value = \"pagenum\")int pagenum, Model model){\r\n\r\n    PageHelper.startPage(pagenum, 5);  //pagenum：页数，pagesize:每页的信息数\r\n    \r\n    List<Type> allType = typeService.getAllType(); //调用业务层查询方法\r\n    \r\n    PageInfo<Type> pageInfo = new PageInfo<>(allType); //得到分页结果对象\r\n    \r\n    model.addAttribute(\"pageInfo\", pageInfo);  //携带分页结果信息\r\n    \r\n    return \"admin/types\";  //回到前端展示页面\r\n}\r\n```\r\n### 四：前端展示分页（thymeleaf+semantic-ui）,这里ui用自己的就行，比如bootstrap或layui，主要是thymeleaf的使用。\r\n\r\n```java\r\n<table  class=\"ui compact celled teal table\">\r\n  <thead>\r\n  <tr>\r\n    <th></th>\r\n    <th>名称</th>\r\n    <th>操作</th>\r\n  </tr>\r\n  </thead>\r\n  <tbody>\r\n  <tr th:each=\"type, iterStat : ${pageInfo.list}\">\r\n    <td th:text=\"${iterStat.count}\">1</td>\r\n    <td th:text=\"${type.name}\">摸鱼方法</td>\r\n    <td>\r\n      <a href=\"#\" th:href=\"@{/admin/types/{id}/input(id=${type.id})}\" class=\"ui mini teal basic button\">编辑</a>\r\n      <a href=\"#\" th:href=\"@{/admin/types/{id}/delete(id=${type.id})}\" class=\"ui mini red basic button\">删除</a>\r\n    </td>\r\n  </tr>\r\n  </tbody>\r\n  <tfoot>\r\n  <tr>\r\n    <th colspan=\"7\">\r\n      <div class=\"ui mini pagination menu\"  >\r\n        <div class=\"item\"><a th:href=\"@{/admin/types}\">首页</a></div>\r\n        <div class=\"item\"><a th:href=\"@{/admin/types(pagenum=${pageInfo.hasPreviousPage}?${pageInfo.prePage}:1)}\">上一页</a></div>\r\n        <div class=\"item\"><a th:href=\"@{/admin/types(pagenum=${pageInfo.hasNextPage}?${pageInfo.nextPage}:${pageInfo.pages})}\">下一页</a></div>\r\n        <div class=\"item\"><a th:href=\"@{/admin/types(pagenum=${pageInfo.pages})}\">尾页</a></div>\r\n      </div>\r\n      <a href=\"#\" th:href=\"@{/admin/types/input}\" class=\"ui mini right floated teal basic button\">新增</a>\r\n    </th>\r\n  </tr>\r\n  </tfoot>\r\n</table>\r\n\r\n<div class=\"ui segment m-inline-block\">\r\n  <p >当前第<span th:text=\"${pageInfo.pageNum}\"></span>页，总<span th:text=\"${pageInfo.pages}\"></span>页，共<span th:text=\"${pageInfo.total}\"></span>条记录</p>\r\n</div>\r\n```\r\n### 五：效果展示（pagesize设置为5的效果）\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200310105006168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODA0NzM2,size_16,color_FFFFFF,t_70)\r\n', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1584368536828&di=460fea188bd56a9f691d87e56622b891&imgtype=0&src=http%3A%2F%2Ftc.sinaimg.cn%2Fmaxwidth.800%2Ftc.service.weibo.com%2Fp3_pstatp_com%2F5ffc4f5b05b15c5642dd59cc7341cc71.jpg', '原创', 0, 1, 0, 1, 1, 1, '2022-09-06 17:05:58', '2022-09-06 17:05:58', 1, 1, '1.在查询方法上调用PageHelper.startPage()方法，设置分页的页数和每页信息数，\r\n2.将查询出来的结果集用PageInfo的构造函数初始化为一个分页结果对象\r\n3.将分页结果对象存入model，返回前端页面', '5,4');
INSERT INTO `t_blog` VALUES (4, 'thymeleaf语法及使用', '## 模板引擎\r\n\r\n简介：模板引擎(这里特指用于Web开发的模板引擎)是为了使用户界面与业务数据(内容)分离而产生的,它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。\r\n模板引擎的思想：\r\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20venltMTk5OS8xNjQ1NDE2L29fMjAwMjExMDk1OTQxMTQucG5n?x-oss-process=image/format,png)\r\nThymeleaf就是SpringBoot给我们推荐的一种模板引擎！\r\n\r\n## Thymeleaf模板引擎\r\n\r\n#### 1.使用Thymeleaf之前的步骤\r\n\r\n 1. Thymeleaf 官网：https://www.thymeleaf.org/\r\n 2. springboot项目直接引入依赖：\r\n```java\r\n<dependency>\r\n   <groupId>org.springframework.boot</groupId>\r\n   <artifactId>spring-boot-starter-thymeleaf</artifactId>\r\n</dependency>\r\n```\r\n3.非springboot项目直接引入依赖：\r\n\r\n```java\r\n<dependency>\r\n    <groupId>org.thymeleaf</groupId>\r\n    <artifactId>thymeleaf</artifactId>\r\n    <version>2.1.4</version>\r\n</dependency>\r\n```\r\n  4.在thymeleaf的配置类ThymeleafProperties中我们可以发现：thymeleaf配置的默认前缀为：\"classpath:/templates/\"，默认后缀为：\".html\"，只要把html页面放在这个路径下，\r\n\r\nthymeleaf就可以帮我们自动渲染。\r\n\r\n```java\r\npublic class ThymeleafProperties {\r\n    private static final Charset DEFAULT_ENCODING;\r\n    public static final String DEFAULT_PREFIX = \"classpath:/templates/\";\r\n    public static final String DEFAULT_SUFFIX = \".html\";\r\n    private boolean checkTemplate = true;\r\n    private boolean checkTemplateLocation = true;\r\n    private String prefix = \"classpath:/templates/\";\r\n    private String suffix = \".html\";\r\n    private String mode = \"HTML\";\r\n...\r\n}\r\n```\r\n如图为用idea创建的springboot的项目结构：将html页面放在resources/templates中即可。\r\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20venltMTk5OS8xNjQ1NDE2L29fMjAwMjExMDk1OTExMTMucG5n?x-oss-process=image/format,png)\r\n#### 2.Thymeleaf语法简单使用（th:text, th:utext, th:each）\r\n编写一个controller实现跳转到一个html页面，通过Model对象携带数据\r\n\r\n```java\r\n@Controller\r\npublic class HelloController {\r\n\r\n    @RequestMapping(\"/success\")\r\n    public String success(Model model){\r\n        //存入数据\r\n        model.addAttribute(\"msg\",\"<h1>Hello</h1>\");\r\n        model.addAttribute(\"users\", Arrays.asList(\"小红\", \"小米\",\"小白\"));\r\n        //classpath:/templates/success.html\r\n        return \"success\";\r\n    }\r\n}\r\n```\r\nsuccess.html\r\n\r\n```java\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n    <h1>success</h1>\r\n\r\n    <!--Thymeleaf语法：th:text就是将div中的内容设置为它指定的值-->\r\n\r\n    <div th:text=\"${msg}\">你好</div>\r\n    <!--utext：会解析html，显示相应的效果-->\r\n    <div th:utext=\"${msg}\">你好</div>\r\n    <!--each：遍历-->\r\n    <h3 th:each=\"user:${users}\" th:text=\"${user}\"></h3>\r\n\r\n</body>\r\n</html>\r\n```\r\n通过http://localhost:8080/success路径访问到success.html页面，同时成功显示数据：![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20venltMTk5OS8xNjQ1NDE2L29fMjAwMjExMTEyOTE3MTUucG5n?x-oss-process=image/format,png)\r\n#### 3.Thymeleaf基本语法（属性和表达式）\r\n**Thymeleaf标准表达式**\r\n   \r\n\r\n 1. 变量表达式：**${ }**：用于前端获取后端传递的变量值\r\n\r\n   \r\n\r\n 1. 选择表达式：***{ }**：用于绑定一个对象的属性\r\n\r\n   \r\n\r\n 1. URL链接表达式：**@{ }**：用于链接\r\n\r\n    \r\n\r\n 1. 条件表达式：**三目运算符（表达式 ？值（then）：值（else））**\r\n\r\n    \r\n\r\n\r\n    \r\n**Thymeleaf属性标签：**\r\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20venltMTk5OS8xNjQ1NDE2L29fMjAwMjExMTEzMTAxMTYucG5n?x-oss-process=image/format,png)\r\n\r\n \r\n\r\n', 'http://n.sinaimg.cn/sinacn20111/600/w1920h1080/20190331/0f41-huxwryw5226043.jpg', '原创', 0, 1, 1, 1, 1, 1, '2022-09-07 10:01:31', '2022-09-07 10:01:31', 1, 1, '简介：模板引擎(这里特指用于Web开发的模板引擎)是为了使用户界面与业务数据(内容)分离而产生的,它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。Thymeleaf就是SpringBoot给我们推荐的一种模板引擎！', '5,3');
INSERT INTO `t_blog` VALUES (5, '利用Set集合去重', '### Set集合特点:\r\n#### ①     一次只存一个元素,\r\n\r\n#### ②     不能存储重复的元素\r\n\r\n#### ③     存储顺序和取出来的顺序不一定一致不能存储重复的元素\r\n\r\n可以利用②这一特点，完成去重的功能。\r\n#### 一：Set集合去掉List集合中重复元素\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n	\r\n	//利用set集合 去除ArrayList集合中的重复元素\r\n	ArrayList<String> list = new ArrayList<>();\r\n	list.add(\"1\");\r\n    list.add(\"1\");\r\n    list.add(\"2\");\r\n    list.add(\"2\");\r\n    list.add(\"3\");\r\n    list.add(\"3\");\r\n    list.add(\"4\");\r\n    list.add(\"4\");\r\n    System.out.println(\"去重前的List集合：\"+list);\r\n    \r\n	Set<String> set = new HashSet<>();\r\n	set.addAll(list);\r\n	System.out.println(\"Set集合：\"+set);\r\n	\r\n	list.clear();            // 清空原有元素 放入被list去重后的元素\r\n	list.addAll(set);\r\n	System.out.println(\"去重后的List集合：\"+list);\r\n}\r\n```\r\n运行结果：\r\n\r\n```java\r\n去重前的List集合：[1, 1, 2, 2, 3, 3, 4, 4]\r\nSet集合：[1, 2, 3, 4]\r\n去重后的List集合：[1, 2, 3, 4]\r\n```\r\n\r\n#### 二：Set集合去掉字符串中重复子串\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n	String str = \"aaab\";\r\n	System.out.println(\"字符串aaab 有非空子串a, b, aa, ab, aaa, aab, aaab，一共 7 个\");\r\n	\r\n	Set<String> set = new HashSet<String>();\r\n	for (int step = 0; step <= str.length() - 1; step++) {\r\n		//扫描全部子串\r\n		for (int begin = 0, end = 1 + step; end <= str.length(); begin++, end++) {     \r\n			String kid = str.substring(begin, end);   //截取字符串子串\r\n			set.add(kid);			//将子串放入set集合，完成去重\r\n		}\r\n	}\r\n	System.out.println(\"去除重复子串后的全部子串有：\"+set.size()+\"个\");\r\n	System.out.println(\"分别是：\" + set);\r\n}\r\n```\r\n运行结果：\r\n```java\r\n字符串aaab 有非空子串a, b, aa, ab, aaa, aab, aaab，一共 7 个\r\n去除重复子串后的全部子串有：7个\r\n分别是：[aa, aaa, a, ab, b, aab, aaab]\r\n```\r\n\r\n', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1584366026862&di=62fd65c3b51d4c6b8052f954ef561268&imgtype=0&src=http%3A%2F%2Fimg.article.pchome.net%2F00%2F38%2F63%2F92%2Fpic_lib%2Fs960x639%2F08s960x639.jpg', '原创', 0, 1, 1, 1, 1, 1, '2022-09-07 11:21:46', '2022-09-07 11:21:46', 3, 1, 'Set集合特点:\r\n① 一次只存一个元素,\r\n② 不能存储重复的元素\r\n③ 存储顺序和取出来的顺序不一定一致不能存储重复的元素', '6');
INSERT INTO `t_blog` VALUES (6, '石家庄铁道大学第五届程序设计竞赛题解', '# <center>石家庄铁道大学第五届程序设计竞赛题解\r\n\r\n本次校赛出题人有7个，每人2道（一道中文，一道英文），总共14道，题目中间更正了一些小问题，对大家造成的不便深感抱歉\r\n\r\n## A-SOUL Eileen Fan F\r\n\r\n**题意：**\r\n\r\n第1行输入一个字符串，代表每一位加法运算所遵循的进制表规则，第2,3行输入两个运算数，按照进制表规则输出运算结果\r\n\r\n**思路：**\r\n\r\n先把2个字符串都在开头补0，使其等长，然后把这2个数加起来，之后进制转换，最后注意输出格式就可以了\r\n\r\n```c++\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n    string a,b,c;\r\n    cin>>c>>a>>b;\r\n    reverse(a.begin(),a.end());\r\n    reverse(b.begin(),b.end());\r\n    reverse(c.begin(),c.end());\r\n    string s;\r\n\r\n    int up=0,sum,k;\r\n    while(a.length()!=b.length()){\r\n        if(a.length()>b.length())\r\n            b += \'0\';\r\n        else\r\n            a += \'0\';\r\n    }\r\n    for(int i=0;i<a.length();i++){\r\n        sum = a[i]-\'0\'+b[i]-\'0\'+up;\r\n        if(i>c.length()-1 || c[i]==\'0\')\r\n            k=10;\r\n        else\r\n            k=c[i]-\'0\';\r\n        up = sum/k;\r\n        sum %= k;\r\n        s = (char)(sum + \'0\') + s;\r\n    }\r\n    if(up > 0)\r\n        s = (char)(up + \'0\') + s;\r\n    int count = 0;\r\n    while(s[count] == \'0\' && s.length() > 1)\r\n        s.erase(count, 1);\r\n    cout<<s<<endl;\r\n    return 0;\r\n\r\n}\r\n```\r\n\r\n## 打牌\r\n\r\n**思路：**\r\n\r\n每个人都可以拿（给自己加分）或者禁（不让对分加禁了的数字的分），所以是拿还是禁就是看能拿的选择和能禁的选择中谁的贡献大（就是面值大），确定了操作方式就可以模拟了\r\n\r\n```c++\r\n#include<iostream>\r\n#include<algorithm>\r\n#define ll long long\r\nusing namespace std;\r\n\r\nint main(){\r\n    int t;\r\n    cin >> t;\r\n    while(t--){\r\n        ll diff = 0,n;\r\n        cin >> n;\r\n        ll arr[200005];\r\n        for(ll i = 0; i < n; i++){\r\n            cin >> arr[i];\r\n        }\r\n        sort(arr,arr + n);\r\n        for(ll i = n - 1; i >= 1; i -= 2){\r\n            ll a = 0,b = 0;\r\n            if(arr[i] % 2 == 0)\r\n                a = arr[i];\r\n            if(arr[i - 1] % 2 != 0)\r\n                b = arr[i - 1];\r\n            diff = diff + a - b;\r\n        }\r\n        if(n % 2 == 1)\r\n            if(arr[0] % 2 == 0)\r\n                diff += arr[0];\r\n        if(diff > 0)\r\n            cout << \"T\" << endl;\r\n        else if(diff < 0)\r\n            cout << \"X\" << endl;\r\n        else cout << \"Tie\" << endl;\r\n    }\r\n    return 0;\r\n}\r\n\r\n```\r\n\r\n## BJS and HT\r\n\r\n**题意：**\r\n\r\n一共有N组条件，每一组有2个字符串（B和H），若H可以由B截取其中K个连续字符并放到最前面得到，那么这组就可以匹配成功，问这N组中有几组可以匹配成功\r\n\r\n**思路:**\r\n\r\n考点：字符串哈希\r\n\r\n - 直接使用`unsigned long long`储存Hash值，计算时不处理算术溢出问题(产生溢出时相当于自动对2^64^取模，这样可以避免低效的mod运算)，且一般取哈希进制数P为131或13331\r\n - 区间$[l,r]$的字符串哈希值公式为：$(H[r]-H[l]*P^{r-l+1}+M)mod\\,M$\r\n - 在 $B$ 串中找连续的 $K$ 个字符，和 $H$ 串前 $K$ 个字符匹配上，之后检验其余部分是否能匹配上即可，最终复杂度为$O(n)$，其中 $n$ 为字符串总长度\r\n\r\n**代码：**\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef unsigned long long ll;\r\nconst int N=5e5+10;\r\nint t,k,n;\r\nll ha[N],hb[N],po[N];\r\nchar a[N],b[N];\r\nll hasha(int l,int r){\r\n	l--;\r\n	return ha[r]-ha[l]*po[r-l];\r\n}\r\nll hashb(int l,int r){\r\n	l--;\r\n	return hb[r]-hb[l]*po[r-l];\r\n}\r\nint cnt=0;\r\nint main(){\r\n	scanf(\"%d\",&t);\r\n	while(t--){\r\n		scanf(\"%s%s%d\",a+1,b+1,&k);\r\n		int n=strlen(a+1);\r\n		\r\n		if(strlen(b+1)!=n || k>n){\r\n			continue;\r\n		}\r\n		\r\n		po[0]=1;\r\n	    for(int i=1;i<=n;i++)\r\n			ha[i]=131*ha[i-1]+a[i],  \r\n        	hb[i]=131*hb[i-1]+b[i],   \r\n        	po[i]=po[i-1]*131;\r\n			\r\n	    ll val=hashb(1,k);//H最前面一段\r\n	    \r\n	    bool flag=0;\r\n        \r\n	    //枚举截取B的左端点i\r\n	    for(int i=1;i+k-1<=n;i++)\r\n	    	if(hasha(i,i+k-1)==val)\r\n                //其他部分匹配上\r\n	    	    if(hasha(1,i-1)==hashb(k+1,k+i-1) && hasha(i+k,n)==hashb(i+k,n)) \r\n                    flag=1;\r\n	    	    \r\n	    if(flag) {\r\n	    	cnt++;\r\n	    }\r\n	}\r\n	cout<<cnt<<endl;\r\n	return 0;\r\n}\r\n```\r\n\r\n## F爱玩炉石传说\r\n\r\n**思路:**\r\n\r\n也是签到题，认真想一下，从1到n检查有没有空缺就可以了\r\n\r\n```c++\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nbool a[1000000];\r\nint n;\r\nint main() {\r\n	cin >> n;\r\n	int t;\r\n	bool flag = 0;\r\n	int k = 0;\r\n	for (int i = 0; i < n; i++) {\r\n		cin >> t;\r\n		//cout<<t;\r\n		if (!a[t]) {\r\n			a[t] = 1;\r\n			k++;\r\n		}\r\n	}\r\n	for (int i = 1; i <= k; i++)\r\n		if (!a[i]) {\r\n			flag = 1;\r\n			break;\r\n		}\r\n	if (flag)\r\n		cout << \"Nevermind, just use the Twisting Nether.\" << endl;\r\n	else\r\n		cout << \"This is a textbook-like blasphemy!\" << endl;\r\n\r\n}\r\n\r\n```\r\n\r\n## A+B Problem\r\n\r\n**思路:**\r\n\r\n每个测试样例不超过 $10$ 组测试数据，实现实数长度 $len$ 不超过 $10^4$ 的大实数加法，注意是否输出小数点，省略无意义的0。时间复杂度 $O(10*len)$。\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <cstring>\r\n#define pb push_back\r\nusing namespace std;\r\n\r\nint main(){\r\n	string a,b;\r\n	while(cin>>a>>b){\r\n		//补0和小数点\r\n		int posa=-1,posb=-1;\r\n		for(int i=0;i<a.size();i++){\r\n			if(a[i]==\'.\'){\r\n				posa=i;\r\n				break;\r\n			}\r\n		}\r\n		for(int i=0;i<b.size();i++){\r\n			if(b[i]==\'.\'){\r\n				posb=i;\r\n				break;\r\n			}\r\n		}\r\n		if(posa==-1){\r\n			a.pb(\'.\');\r\n			a.pb(\'0\');\r\n		}\r\n		else if(posb==-1){\r\n			b.pb(\'.\');\r\n			b.pb(\'0\');\r\n		}\r\n		\r\n		if(a.size()<b.size()){\r\n			swap(a,b);	\r\n		}\r\n		//看小数点的位置 \r\n		posa=posb=0;\r\n		for(int i=0;i<a.size();i++){\r\n			if(a[i]==\'.\'){\r\n				break;\r\n			}\r\n			posa++;\r\n		}\r\n		for(int i=0;i<b.size();i++){\r\n			if(b[i]==\'.\'){\r\n				break;\r\n			}\r\n			posb++;\r\n		}\r\n		if(posa<posb){\r\n			string tem=\"\";\r\n			for(int i=0;i<posb-posa;i++){\r\n				tem.pb(\'0\');\r\n			}\r\n			tem+=a;\r\n			a=tem;\r\n		}\r\n		else{\r\n			string tem=\"\";\r\n			for(int i=0;i<posa-posb;i++){\r\n				tem.pb(\'0\');\r\n			}\r\n			tem+=b;\r\n			b=tem;\r\n		}\r\n		\r\n		int d=a.size()-b.size();\r\n		for(int i=0;i<d;i++){\r\n			b.push_back(\'0\');\r\n		}\r\n		int x=a.size(),y=b.size();\r\n		if(a.size()<b.size()){\r\n			for(int i=0;i<(y-x);i++){\r\n				a.pb(\'0\');\r\n			}\r\n		}\r\n		\r\n		reverse(a.begin(),a.end());\r\n		reverse(b.begin(),b.end());\r\n		\r\n		string ans=\"\";\r\n		int up=0;\r\n		for(int i=0;i<a.size();i++){\r\n			if(a[i]==\'.\'){\r\n				ans.pb(\'.\');\r\n				continue;\r\n			}\r\n			ans.pb((a[i]-\'0\'+b[i]-\'0\'+up)%10+48);\r\n			up=(up+a[i]-\'0\'+b[i]-\'0\')/10;\r\n		}\r\n		if(up){\r\n			ans.pb(up+48);\r\n		}\r\n		reverse(ans.begin(),ans.end());\r\n		\r\n		int pos=-1;\r\n		for(int i=0;i<ans.size();i++){\r\n			if(ans[i]==\'.\'){\r\n				pos=i;\r\n				break;\r\n			}\r\n		}\r\n		\r\n		//去除后导零 \r\n		bool flag=1;\r\n		for(int i=pos+1;i<ans.size();i++){\r\n			if(ans[i]!=\'0\'){\r\n				flag=0;\r\n				break;\r\n			}\r\n		}\r\n		if(flag){//全是0 \r\n			for(int i=0;i<pos;i++){\r\n				cout<<ans[i];\r\n			}\r\n			cout<<endl;\r\n		}\r\n		else{\r\n			int len=ans.size();\r\n			for(int i=ans.size()-1;i>=0;i--){\r\n				if(ans[i]==\'0\'){\r\n					len--;\r\n				}\r\n				else{\r\n					break;\r\n				}\r\n			}\r\n			for(int i=0;i<len;i++){\r\n				cout<<ans[i];\r\n			}\r\n			cout<<endl;\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n```\r\n\r\n## 懒虫读诗\r\n\r\n**思路:**\r\n\r\n**考点：**背包DP，树形 DP\r\n\r\n我们可以抽象为有根树中一个点最多只有一个父亲结点，这是一个森林，方便起见，我们可以新增一篇开心度为 $0$ 的文章（设这篇文章的开心度为 $0$ ），作为所有无先导诗文篇章的先导诗文，这样我们就将森林变成了一棵以 $0$ 号诗文为根的树，而且恰好满足题意输入\r\n\r\n设$f(i,u,j)$表示以 $i$ 号点为根的子树中，已经遍历了 $i$ 号点的前 $u$ 棵子树，选了 $j$ 篇文章的当前累计最大开心值之和，转移的过程中，我们枚举 $i$ 点的每个子结点 $v$，同时枚举以 $v$ 为根的子树选的文章数（设为 $k$ ），将子树的结果合并到 $i$ 上，另外，设以 $v$ 为根的子树大小为$size_v$，点 $v$ 的儿子个数为 $s_{v}$ ，有状态转移方程：\r\n\r\n$$f(i,u,j)=\\max _{k<size_v}f(i,u-1,j-k)+f(v,s_{v},k)$$\r\n\r\n$f$ 的第二维可以用滚动数组的方式省略掉，这时设$f(i,j)$为在 $i$ 及 $i$ 以下的子树上选 $j$ 篇文章（范围在 $1$ 至 $m+1$ ）所能得到的当前累计最大开心值之和，注意这时需要倒序枚举 $j$ 的值，对于 $k$ ，从 $0$ 至 $j-1$ 枚举就好了，而且我们可以证明，该做法的时间复杂度为$O(nm)$ \r\n\r\n**代码：**\r\n\r\n```c++\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nconst int N=300+10;\r\nint f[N][N];\r\nvector<int> table[N];\r\nint n,m;\r\n\r\nvoid dp(int a){\r\n	for(auto i : table[a]){\r\n		dp(i);\r\n        //类似背包\r\n		for (int j=m+1;j>=1;j--)\r\n			for(int k=0;k<j;k++)\r\n				f[a][j]=max(f[a][j],f[a][j-k]+f[i][k]);\r\n	}\r\n}\r\nint main(){\r\n	cin>>n>>m;\r\n	int ki=0;\r\n	for(int i=1;i<=n;i++){\r\n		cin >> ki >> f[i][1];\r\n		table[ki].push_back(i);\r\n	}\r\n\r\n	dp(0);\r\n	cout<<f[0][m+1];\r\n}\r\n```\r\n\r\n## A Hard Calculation Problem\r\n\r\n**思路：**\r\n\r\n签到题，直接输出对应校赛的举办时间即可\r\n\r\n**代码：**\r\n\r\n```c++\r\n#include <bits/stdc++.h>\r\n#define closeSync ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\r\n#define multiCase int T;cin>>T;for(int t=1;t<=T;t++)\r\n#define debug(x) cout<<#x<<\":\"<<x<<endl;\r\n#define f(i,a,n) for(int i=a;i<n;++i)\r\n#define ff(i,a,n) for(int i=a;i<=n;++i)\r\nconst int INF=0x3f3f3f3f;\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef double dbl;\r\ntypedef pair<int, int> pi;\r\nint t;\r\nint q=2021-5;\r\nint main(){\r\n	cin>>t;\r\n	int x;\r\n	while(t--){\r\n		cin>>x;\r\n		cout<<x+q<<endl;\r\n	}\r\n    return 0;\r\n}\r\n```\r\n\r\n## 水果蛋糕\r\n\r\n**思路：**\r\n\r\n本题所需解决的问题有3个：\r\n\r\n1. 计算蛋糕的大小：观察题目，我们可以知道蛋糕的宽都是相同的，因此判断每块蛋糕的面积的大小只需要判断蛋糕上下底边的和的大小即可\r\n2. 统计每块蛋糕上水果的个数：枚举每个水果的坐标，使用二分查找（通过向量的叉积判断水果在断口的左边还是右边）水果左边最右边的断口（或右边最左边的断口），统计每个断口被查找的次数即可求出每块蛋糕上水果的次数（蛋糕边缘的切割点的坐标可以利用前缀和求出）\r\n3. 找出所求蛋糕：可以通过记录当前最优解查找，也可使用结构体排序后直接选出\r\n\r\n**代码：**\r\n\r\n```c++\r\n#include<iostream>\r\n#include<algorithm>\r\n#include<cstring>\r\n#include<cstdio>\r\nusing namespace std;\r\ndouble us[10000020],ds[10000020];\r\ndouble u[10000020],d[10000020];\r\nint cnt[5000010];\r\ndouble cj(double x1,double y1,double x2,double y2){\r\n	return x1*y2-x2*y1;\r\n}\r\ndouble pd(double x1,double y1,double x2,double y2,double x3,double y3){\r\n	return cj(x2-x1,y2-y1,x3-x1,y3-y1);\r\n}\r\nstruct Cake{\r\n	int cnt,sqr,num;\r\n}c[10000020];\r\n\r\nbool cmp(struct Cake a,struct Cake b){\r\n	if(a.cnt != b.cnt )return a.cnt > b.cnt ;\r\n	else if(a.sqr!=b.sqr )return a.sqr >b.sqr ;\r\n	else return a.num<b.num;\r\n}\r\nint main(){\r\n	int n,m;\r\n	scanf(\"%d %d\",&n,&m);\r\n	int xx,yy;\r\n	scanf(\"%d %d\",&xx,&yy);\r\n	for(int i=1;i<=n;i++){\r\n		scanf(\"%lf %lf\",&us[i],&ds[i]);\r\n		u[i]=u[i-1]+us[i];\r\n		d[i]=d[i-1]+ds[i];\r\n		c[i].sqr=us[i]+ds[i];\r\n		c[i].num=i;\r\n	}\r\n	c[n+1].sqr=xx-u[n]+xx-d[n]; \r\n	c[n+1].num=n+1; \r\n	for(int i=0;i<m;i++){\r\n		double x,y;\r\n		scanf(\"%lf %lf\",&x,&y);\r\n		int l=1,r=n+1;\r\n		while(l!=r){\r\n			int mid=(l+r)/2;\r\n			if(pd(u[mid],yy,d[mid],0,x,y)>0){\r\n				l=mid+1;\r\n			}else{\r\n				r=mid;\r\n			}\r\n		}\r\n		c[l].cnt++;\r\n	}\r\n	sort(c+1,c+n+2,cmp);\r\n	printf(\"%d\",c[1].num);\r\n} \r\n```\r\n\r\n\r\n\r\n## Digital Logic and Bit Operation\r\n\r\n\r\n\r\n**题意：**\r\n\r\n找到[l,r]中的x、y，使得x|y最大。\r\n\r\n**思路：**\r\n\r\n二分+位运算\r\n\r\n给l的二进制补1，只要没超过r就一直补，最后得到的数和r或运算就是结果。\r\n\r\n```c++\r\n#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nint main(){\r\n    ll ans;\r\n    ll l,r;\r\n    int t;\r\n    cin >> t;\r\n    while(t--){\r\n        cin >> l >> r;\r\n        ll now = 0;\r\n        while((l|(ll)1 << now) < r){\r\n            l |= ((ll)1 << now);\r\n            now++;\r\n        }\r\n        cout << (l|r) << endl;\r\n    }\r\n}\r\n```\r\n\r\n## 蛋糕惨案\r\n\r\n**思路：**\r\n\r\n本题所需解决的问题有2个：\r\n\r\n1. 快速的求出范围内的所有质数：很明显使用定义来判断质数的总时间复杂度为$O(n\\sqrt n)$，而本题的数据范围在1e7，肯定会超时，接下来采用埃氏筛，其效率是$O(nlglgn)$，虽然已经很快了，但是在残暴数据1e7面前仍会超时，最后便是本题的正解：欧拉筛（线性筛）正如名字那样，他的时间复杂度为$O(n)$，在利用线性筛打好表后，我们只需要枚举每个数，判断他们是否是素数，如果是则把他们存在一个数组中\r\n2. 对数组进行排序：大概有$\\dfrac{n}{ln(n)}$个素数，最后我们直接进行排序就好（排序使用时间复杂度不超过$O(nlgn)$即可）\r\n\r\n**代码：**\r\n\r\n```c++\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<time.h>\r\n#include<cmath>\r\n#include<algorithm>\r\n#include<iostream>\r\nusing namespace std;\r\nbool cmp(int a,int b){\r\n	return a<b;\r\n}\r\nint primes[10000010], cnt;\r\nbool st[10000010];\r\nint s[10000010];\r\nint main(){\r\n	st[1]=1;\r\n    for (int i = 2; i <= 1e7; i ++ ){\r\n        if (st[i]) continue;\r\n        primes[cnt ++ ] = i;\r\n        for (int j = i + i; j <= 1e7; j += i)\r\n            st[j] = true;\r\n    }\r\n	int n;\r\n	scanf(\"%d\",&n);\r\n	\r\n	int top=0;\r\n	for(int i=0;i<n;i++){\r\n		int now;\r\n		scanf(\"%d\",&now);\r\n		if(st[now]==0){\r\n			s[top++]=now;\r\n		}\r\n	}\r\n	sort(s,s+top,cmp);\r\n	printf(\"%d\\n\",top);\r\n	if(top==0)printf(\"-1\");\r\n	else {\r\n		for(int i=0;i<top;i++){\r\n			printf(\"%d \",s[i]);\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n## Equation\r\n\r\n**题意：**\r\n\r\n输入y，找出输入后函数在0-100上的最小值\r\n\r\n**思路：**\r\n\r\n**算法：**二分法求解\r\n\r\n给原方程求导之后运用二分法求解。\r\n\r\n```c++\r\n#include<iostream>\r\n#include<algorithm>\r\n#include<math.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\ndouble fx(double x,double y){\r\n    return 6 * pow(x,7) + 8 * pow(x,6) + 7 * x*x*x + 5 * x*x - y * x;\r\n}\r\n\r\ndouble gx(double x,double y){\r\n    return 42 * pow(x,6) + 48 * x*x*x*x*x + 21 * x*x + 10 * x - y;\r\n}\r\n\r\nint main(){\r\n    int t;\r\n    cin >> t;\r\n    while(t--){\r\n        double y;\r\n        cin >> y;\r\n        if(gx(100,y) <= 0){\r\n            cout << fx(100,y) << endl;\r\n            continue;\r\n        }\r\n        else{\r\n            double low = 0,high = 100,mid;\r\n            while(high - low > 0.00001){\r\n                mid = (high + low)/2;\r\n                if(gx(mid,y) >= 0) high = mid;\r\n                else low = mid;\r\n            }\r\n            printf(\"%.4lf\\n\",fx(mid,y));\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n```\r\n\r\n## 树上宝藏\r\n\r\n**思路：**\r\n\r\n给定一颗 $n \\leq 10^5$ 的无根树 ($a!=b$，保证无环)，注意到 $1 \\leq m \\leq 10^2$ ，题目要求 $O(m)$ 次树上修改，$O(m)$ 次树上询问。因此使用邻接表建图之后，对每次修改和查询暴力 $dfs$ 求解即可，注意开 $long long $，时间复杂度$O(n*m)。$\r\n\r\n```cpp\r\n#include<iostream>\r\n#include<cstring>\r\nusing namespace  std;\r\ntypedef long long ll;\r\nconst int N=1e5+10;\r\n\r\nint h[N],e[N*2],ne[N*2],idx;\r\nll w[N],ans;\r\nint n,m;\r\n\r\nvoid add(int a,int b){\r\n	e[idx]=b,ne[idx]=h[a],h[a]=idx++;\r\n}\r\nbool flag=0;\r\nvoid dfs(int u,int fa,int v,ll d){\r\n	if(u==v){\r\n		w[v]+=d;\r\n		flag=1;\r\n		return ;\r\n	}\r\n	w[u]+=d;\r\n	for(int i=h[u];~i;i=ne[i]){\r\n		int j=e[i];\r\n		if(j==fa)continue;\r\n		dfs(j,u,v,d);\r\n		if(flag)return ;\r\n	}\r\n	w[u]-=d;\r\n}\r\n\r\nvoid dfs_1(int u,int fa,int v,int res){\r\n	if(u==v){\r\n		res+=w[u];\r\n		ans=res;\r\n		return ;\r\n	}\r\n	res+=w[u];\r\n	for(int i=h[u];~i;i=ne[i]){\r\n		int j=e[i];\r\n		if(j==fa)continue;\r\n		dfs_1(j,u,v,res);\r\n	}\r\n	res-=w[u];\r\n	return ;\r\n}\r\n\r\nint main(){\r\n	cin>>n>>m;\r\n	memset(h,-1,sizeof h);\r\n	for(int i=1;i<=n;i++){\r\n		cin>>w[i];\r\n	}\r\n	for(int i=0;i<n-1;i++){\r\n		int a,b;\r\n		scanf(\"%d%d\",&a,&b);\r\n		add(a,b);add(b,a);\r\n	}\r\n	for(int i=0;i<m;i++){\r\n		int u,v;cin>>u>>v;\r\n		ll d;cin>>d;\r\n		flag=0;\r\n		dfs(u,-1,v,d);\r\n	}\r\n	for(int i=0;i<m;i++){\r\n		int u,v;cin>>u>>v;\r\n		ans=0;\r\n		dfs_1(u,-1,v,0);\r\n		cout<<ans<<endl;\r\n	}\r\n	return 0;\r\n}\r\n```\r\n\r\n## Rescue Hostage\r\n\r\n**思路：**\r\n\r\n题目要求两个人到达同一地点所需时间最少，所以可以对每个人分别bfs一下，找到之和最小的那个点即可\r\n\r\n```c++\r\n#include<iostream>\r\n#include<queue>\r\n#include<string>\r\nusing namespace std;\r\nconst int N = 1010;\r\nint ansa[205][205];\r\nint ansb[205][205];\r\nchar s[205][205];\r\nconst int dx[4] = { 1,-1,0,0 };\r\nconst int dy[4] = { 0,0,1,-1 };\r\nint xy, yy, xm, ym;\r\nint n, m;\r\nstruct node{\r\n	int x, y;\r\n};\r\nint lans = 10010;\r\nbool judge(int x0, int y0, int ans[205][205]){\r\n	if (x0 < 0 || x0 >= n || y0 < 0 || y0 >= m)\r\n		return false;\r\n	if (ans[x0][y0])\r\n		return false;\r\n	if (s[x0][y0] == \'#\')\r\n		return false;\r\n	else\r\n		return true;\r\n}\r\nvoid bfs(int x, int y, int ans[205][205]){\r\n	queue<node> q;\r\n	node p1;\r\n	p1.x = x;\r\n	p1.y = y;\r\n	ans[x][y] = 0;\r\n	q.push(p1);\r\n	while (!q.empty()){\r\n		node p2;\r\n		p2 = q.front();\r\n		q.pop();\r\n		for (int i = 0; i < 4; i++){\r\n			p1.x = p2.x + dx[i];\r\n			p1.y = p2.y + dy[i];\r\n			if (judge(p1.x, p1.y, ans)){\r\n				ans[p1.x][p1.y] = ans[p2.x][p2.y] + 1;\r\n				q.push(p1);\r\n			}\r\n		}\r\n	}\r\n}\r\nint main(){\r\n	cin >> n >> m;\r\n		lans = 10010;\r\n		memset(ansa, 0, sizeof(ansa));\r\n		memset(ansb, 0, sizeof(ansb));\r\n		for (int i = 0; i < n; i++){\r\n			for (int j = 0; j < m; j++){\r\n				cin >> s[i][j];\r\n				if (s[i][j] == \'F\'){\r\n					xy = i;\r\n					yy = j;\r\n				}\r\n				else if (s[i][j] == \'X\'){\r\n					xm = i;\r\n					ym = j;\r\n				}\r\n			}\r\n		}\r\n		bfs(xy, yy, ansa);\r\n		bfs(xm, ym, ansb);\r\n		for (int i = 0; i < n; i++)\r\n			for (int j = 0; j < m; j++){\r\n				if (s[i][j] == \'H\' && ansa[i][j] != 0){\r\n					int temp = ansa[i][j] + ansb[i][j];\r\n					lans = min(lans, temp);\r\n				}\r\n			}\r\n		cout << lans << endl;\r\n}\r\n```\r\n\r\n## 嘉然的问题\r\n\r\n**思路：**\r\n\r\n签到题，为啥都不做捏QAQ，直接枚举所有的子串，然后判断是否回文就好了，因为输入字符串中间可能会有空格，所以输入方式推荐用getline\r\n\r\n**代码：**\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nstring s;\r\nvoid judge(int pos,int len){\r\n	string s1=s.substr(pos,len);\r\n	string s2=s1;\r\n	reverse(s1.begin(),s1.end());\r\n	if(s1==s2)cout<<s1<<endl;\r\n}\r\nint main(){\r\n    getline(cin,s);\r\n    int l=s.length();\r\n    for(int i=2;i<=l;i++)\r\n		for(int j=0;j+i<=l;j++)\r\n			judge(j,i);\r\n			\r\n    return 0;\r\n}\r\n```\r\n\r\n', 'http://p.qpic.cn/dnfbbspic/0/dnfbbs_dnfbbs_dnf_gamebbs_qq_com_forum_202002_04_082156ifotspmtuzcffycn.jpg/0', '原创', 0, 1, 1, 1, 1, 1, '2022-09-07 11:54:41', '2022-09-07 11:54:41', 2, 1, '石家庄铁道大学第五届程序设计竞赛题解', '4');
INSERT INTO `t_blog` VALUES (7, '石家庄铁道大学2021年天梯赛选拔赛题解', '# <center>石家庄铁道大学2021年天梯赛选拔赛题解\r\n\r\n## [开心签到](https://ac.nowcoder.com/acm/contest/13545/A)\r\n\r\n签到\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n    int n;\r\n    cin>>n;\r\n    string s;\r\n    while(n){\r\n        s+=n%10+\'0\';\r\n        n/=10;\r\n    }\r\n    cout<<s<<endl;\r\n    return 0;\r\n}\r\n```\r\n\r\n## [开心模拟](https://ac.nowcoder.com/acm/contest/13545/B)\r\n\r\n可以桶排\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nconst int maxn=3e4+5;\r\nint a[maxn];\r\nint main(){\r\n	int n,k,max=0;\r\n	cin>>n;\r\n	for(int i=1;i<=n;i++){\r\n		cin>>k;\r\n		a[k]++;\r\n	}\r\n	for(int i=1;i<=30000;i++)\r\n		if(a[i]>max)\r\n			max=a[i];\r\n	for(int i=1;i<=30000;i++)\r\n		if(a[i]==max)\r\n			cout<<i<<\" \"<<a[i]<<endl;\r\n	return 0;\r\n}\r\n```\r\n\r\n## [开心的斐波那契](https://ac.nowcoder.com/acm/contest/13545/C)\r\n\r\n注意开 `long long`\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\ntypedef long long ll;\r\nusing namespace std;\r\nint main() {\r\n	ll a[105]={0,0,1};\r\n	int n;\r\n	scanf(\"%d\",&n);\r\n	for(int i=3;i<=n;i++) \r\n		a[i]=a[i-1]+a[i-2];\r\n	printf(\"%lld\",a[n]);\r\n	return 0;\r\n}\r\n```\r\n\r\n## [开心晚会](https://ac.nowcoder.com/acm/contest/13545/D)\r\n\r\n- 法一：map来$O(nlogn)$累加个数,然后$O(n)$遍历\r\n- 法二：异或（xor）满足结合律与交换律，如果最后有不成对的就会留下，所以遍历所有数字，剩下的就是那个孤立的数字（xor：只有在两个比较的位不同时其结果是1，否则结果为0）\r\n\r\n**法一：**\r\n\r\n```c++\r\n#include<iostream>\r\n#include<map>\r\nusing namespace std;\r\nint main(){\r\n    int n;\r\n    map<int,int> a;\r\n    cin>>n;\r\n    int t;\r\n    for(int i=0;i<n;i++){\r\n        cin>>t;\r\n        a[t]++;\r\n    }\r\n    for(map<int,int>::iterator i=a.begin();i!=a.end();i++)\r\n        if((i->second)%2==1){\r\n            cout<<i->first<<endl;\r\n            break;\r\n        }\r\n}\r\n```\r\n\r\n**法二：**\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n	int ans,n;\r\n	cin>>n>>ans;\r\n	for(int i=2;i<=n;i++){\r\n		int t;\r\n		cin>>t;\r\n		ans=ans^t;\r\n	}\r\n	cout<<ans;\r\n	return 0;\r\n}\r\n```\r\n\r\n## [开心树](https://ac.nowcoder.com/acm/contest/13545/E)\r\n\r\n**法一：**\r\n\r\n一天一天模拟即可，$O(n)$\r\n\r\n```c++\r\n#include<iostream>\r\nusing namespace std;\r\nlong long ans,n;\r\nint cnt=1;\r\nint main(){\r\n    cin>>n;\r\n    int j=0;\r\n    for(int i=1;i<=n;i++){\r\n        ans+=cnt;\r\n        j++;\r\n        if(j==cnt) cnt++,j=0;\r\n    }\r\n    cout << ans << endl;\r\n}\r\n```\r\n\r\n**法二：**\r\n\r\n卡时间时，这是通解，$O(\\sqrt{n})$，当然可以二分找 $t$，那么就 $O(log{n})$了\r\n\r\n推公式，先找到一个 $t$ 满足$\\dfrac{\\left( 1+t\\right) *t}{2}\\leq n< \\dfrac{\\left( t+1\\right) * (t+2)}{2}$,然后求$\\left( 1+t\\right) \\left( n-\\dfrac{\\left( 1+t\\right) t}{2}\\right)+\\sum ^{t}_{i=1}i^{2}$即可\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\ntypedef long long ll;\r\nusing namespace std;\r\nint main(){\r\n    int n;\r\n    cin >> n;\r\n    int d;\r\n    for(int i=0;i<=sqrt(2*n)+1;i++){\r\n    	if(i*(i+1)/2>n){\r\n    		d=i;break;\r\n		}\r\n	}\r\n	d--;\r\n	ll sum=0;\r\n	sum+=(1+d)*(n-d*(d+1)/2);\r\n	for(int i=1;i<=d;i++)\r\n		sum+=i*i;\r\n	cout<<sum<<endl;\r\n}\r\n```\r\n\r\n## [开心数](https://ac.nowcoder.com/acm/contest/13545/F)\r\n\r\n本题不能暴力去做，题解是薛同写的，在此放上\r\n\r\n**解释：**\r\n\r\n题意不太清楚，在此道歉，开心数应该是它的二进制数位上**有且仅有一位**是为0的\r\n\r\n**思路：**\r\n\r\n找出所有在二进制表示的情况下，所有位数都为1的数。然后拿这些数分别减2的次幂（其指数比该数的最高位数低）的所有情况，一 一列举\r\n\r\n例如：\r\n\r\n11     10\r\n\r\n111    110 101\r\n\r\n1111    1110 1101 1011\r\n\r\n先将上述的枚举数存到数组，再根据给的范围得出所喜欢的数的个数\r\n\r\n```c++\r\n#include<iostream>\r\nusing namespace std;\r\ntypedef long long ll;\r\nll n[61] = { 1 };\r\nll m[2000] = { 0 };\r\nint cnt = 1;\r\nvoid init(){\r\n    //n存储2的0-60次幂，因为10^18的二进制位位数为60\r\n    for (int i = 1; i < 61; i++)\r\n        n[i] = n[i-1] * 2;\r\n    //选择一个1挖掉,m存储二进制仅含一个零的数（m数组一定严格递增）\r\n    for (int i = 2; i < 61; i++)\r\n        for (int j = i - 2; j >= 0; j--)\r\n            m[cnt++] = n[i] -1 - n[j] ;//枚举喜欢的数\r\n}\r\nint main() {\r\n    init();\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        ll l, r;\r\n        cin >> l >> r;\r\n        int pos = 0;\r\n        while (m[pos] < l) pos++;\r\n        int count = 0;\r\n        for (; pos <= cnt; pos++) {\r\n            if (m[pos] > r)\r\n                break;\r\n            count++;\r\n        }\r\n        cout << count << endl;\r\n    }\r\n}\r\n```\r\n\r\n## [开心整数](https://ac.nowcoder.com/acm/contest/13545/G)\r\n\r\n**思路：**\r\n\r\n暴力打表判断就好(不打表也能过)，好多人wa在了0的判断，0!=1，那么0不能表示成为一些互不相同的整数的阶乘之和，所以输出NO就好了\r\n\r\n枚举代码：\r\n\r\n```c++\r\n#include<iostream>\r\nusing namespace std;\r\nint n;\r\nint m[10] = { 1 };\r\nint main() {\r\n    for (int i = 1; i < 10; i++)\r\n        m[i] = m[i - 1] * i;\r\n    while (cin >> n && n >= 0) {\r\n        if (n != 0) {\r\n            for (int i = 9; i >= 0; i--) {\r\n                if (n >= m[i])\r\n                    n = n - m[i];\r\n                if (n == 0) {\r\n                    cout << \"YES\" << endl;\r\n                    break;\r\n                }\r\n            }\r\n            if (n)\r\n                cout << \"NO\" << endl;\r\n        }\r\n        else\r\n            cout<<\"NO\"<<endl;\r\n    }\r\n}\r\n```\r\n\r\ndfs代码:\r\n\r\n```c++\r\n#include<iostream>\r\n#include<cstdio>\r\nusing namespace std;\r\ntypedef long long ll;\r\nconst int mod=100003;\r\nll a[13];\r\nbool st[1000010];\r\n//现在的开心数，阶乘所在位置\r\nvoid dfs(int x, int p){\r\n    if(p==-1) return;\r\n    st[x+ a[p]]=1;\r\n    dfs(x, p - 1);//不加\r\n    dfs(x + a[p], p - 1);//加\r\n}\r\nint main(){\r\n    a[0]=a[1]=1;\r\n    for(int i=2;i<10;i++) {\r\n        a[i]=a[i-1]*i;\r\n    }\r\n    dfs(0, 9);\r\n    int x;\r\n    while(scanf(\"%d\",&x),x>=0){\r\n        if(st[x]) cout<<\"YES\"<<endl;\r\n        else cout<<\"NO\"<<endl;\r\n    }\r\n}\r\n```\r\n\r\n## [开心扫雷](https://ac.nowcoder.com/acm/contest/13545/H)\r\n\r\n**思路：**\r\n\r\n简单bfs，3X3的块间没有干扰，所以queue也不需要，枚举就可以\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nconst int N = 1e6;\r\nchar mp[103][103];\r\nint dir[][2] = {1, 0, 0, 1, 1, -1, -1, 1, -1, 0, 0, -1, -1, -1, 1, 1};\r\nint main() {\r\n    int n, m;\r\n    cin >> n >> m;\r\n    for(int i = 0; i < n; ++i) {\r\n        cin >> (mp[i + 1] + 1);\r\n    }\r\n    for(int i = 1; i <= n; ++i) {\r\n        for(int j = 1; j <= m; ++j) {\r\n            if(mp[i][j] == \'*\') {\r\n                cout << \"*\";\r\n                continue;\r\n            }\r\n            int cnt = 0;\r\n            for(int k = 0; k < 8; ++k) {\r\n                int x = i + dir[k][0];\r\n                int y = j + dir[k][1];\r\n                if(mp[x][y] == \'*\') cnt++;\r\n            }\r\n            cout << cnt;\r\n        }\r\n        cout << endl;\r\n    }\r\n    return 0;\r\n}\r\n```\r\n\r\n## [奇怪的比赛](https://ac.nowcoder.com/acm/contest/13545/I)\r\n\r\n**思路：**\r\n\r\n并查集，如果2个人是朋友，就union起来，如果是敌人，就把自己和对方的朋友union起来，中间标记一下自己的敌人就好\r\n\r\n```c++\r\n#include<iostream>\r\nusing namespace std;\r\nint p[1005];\r\nint d[1005];\r\nint find(int x) {\r\n    if (x == p[x]) return x;\r\n    return p[x] = find(p[x]);\r\n}\r\nvoid un(int x, int y) {\r\n    int a = find(x);\r\n    int b = find(y);\r\n    if (a != b) p[b] = a;\r\n}\r\nint main() {\r\n    int n, m;\r\n    int v, x, y;\r\n    cin >> n >> m;\r\n    for (int i = 1; i <= n; i++) p[i] = i;\r\n    for (int i = 0; i < m; i++) {\r\n        cin >> v >> x >> y;\r\n        if (!v){\r\n            un(x, y);//连接队友\r\n        }\r\n        else {//x和y是敌人\r\n            if (d[x])\r\n                un(y, d[x]);//x的敌人是y的朋友，连接2个集合\r\n            if (d[y])\r\n                un(x, d[y]);//y的敌人是x的朋友，连接2个集合\r\n            //标记敌人\r\n            d[x] = y;\r\n            d[y] = x;\r\n        }\r\n    }\r\n    int s = 0;\r\n    for (int i = 1; i <= n; i++)\r\n        if (p[i] == i)\r\n            s++;\r\n    cout << s;\r\n}\r\n```\r\n\r\n## [开心括号](https://ac.nowcoder.com/acm/contest/13545/J)\r\n\r\n题目全半角搞混了，在此道歉QAQ\r\n\r\n**思路：**\r\n\r\n栈的基本应用，用数组模拟或者写一个栈就好\r\n\r\n数组：\r\n\r\n```c++\r\n#include<iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\nusing namespace std;\r\nchar c[300];\r\nint cnt;\r\nint main(){\r\n    string s;\r\n    cin>>s;\r\n    int len=s.size();\r\n    for(int i=0;i<len;i++){\r\n        if(cnt!=0 && (s[i]==\')\'&&c[cnt]==\'(\' || s[i]==\']\'&&c[cnt]==\'[\')) cnt--;\r\n        else c[++cnt]=s[i];\r\n    }\r\n    if(cnt==0) cout<<\"happy\"<<endl;\r\n    else cout<<\"unhappy\"<<endl;\r\n}\r\n```\r\n\r\nSTL(这里直接find函数了):\r\n\r\n```c++\r\n#include<iostream>\r\nusing namespace std;\r\nint cnt;\r\nint main(){\r\n    string s;\r\n    cin>>s;\r\n    string::iterator it=s.begin();\r\n    while(1){\r\n        int pos=0;\r\n        if(s.find(\"()\")!=-1){\r\n            pos=s.find(\"()\");\r\n            s.erase(it+pos,it+pos+2);\r\n        }\r\n        else if(s.find(\"[]\")!=-1){\r\n            pos=s.find(\"[]\");\r\n            s.erase(it+pos,it+pos+2);\r\n        }\r\n        else break;\r\n    }\r\n    if(s.size()==0) cout<<\"happy\"<<endl;\r\n    else cout<<\"unhappy\"<<endl;\r\n}\r\n```\r\n\r\n## [开心糖葫芦](https://ac.nowcoder.com/acm/contest/13545/K)\r\n\r\n**思路：**\r\n\r\n一道简单数学题，正向考虑卖不出去的个数有点难搞，那就逆向，考虑能卖出去的情况数，1号小圆球可以有M个情况，2号小圆球就有(M-1)个情况，3号小圆球也是(M-1)个情况，以此类推得到能卖出去的情况数为：$M*(M-1)^{(N-1)} $,总方案数为：$M^N$，注意模数作差即可\r\n\r\n```c++\r\n#include<iostream>\r\nusing namespace std;\r\ntypedef long long ll;\r\nconst ll mod= 100003;\r\nll n,m,p;\r\n//快速幂\r\nll qpow(ll a,ll b){\r\n    ll ans = 1;\r\n    while(b){\r\n        if(b&1) ans = (ans*a)%mod;\r\n        b/=2;\r\n        a = (a*a)%mod;\r\n    }\r\n    return ans;\r\n}\r\nint main(){\r\n    cin>>m>>n;\r\n    printf(\"%lld\\n\",(qpow(m,n)-(m*qpow(m-1,n-1))%mod+mod)%mod);\r\n    return 0;\r\n}\r\n```\r\n\r\n## [开心矩阵](https://ac.nowcoder.com/acm/contest/13545/L)\r\n\r\n**思路：**\r\n\r\nabc 3个矩阵的乘积方式有abc，acb，bac，bca，cab，cba 6种\r\n\r\n那么枚举这6种的开心值，如果开心值不存在，就是-1\r\n\r\n最后如果6种情况都是-1，输出ERROR，反之输出这六个数的最大值\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\n#define ll long long\r\n#define fo(i,a,b) for(int i=a;i<b;i++)\r\nusing namespace std;\r\nll a[105][105],b[105][105],c[105][105];\r\nll d[105][105],e[105][105];\r\nll happy[10];\r\nconst ll mod=1e9+7;\r\n//计算[n,m] * [m,p]的乘积，存于后一个矩阵\r\nvoid calculate(ll n, ll m, ll p, ll t1[105][105], ll t2[105][105]){\r\n    memset(d,0,sizeof d);\r\n    int row=0;//记录d矩阵到哪一行了\r\n    int col=0;//记录d矩阵到哪一列了\r\n    fo(i,0,n)fo(j,0,p){\r\n        ll sum=0;\r\n        fo(k,0,m){\r\n            sum+= 1LL * t1[i][k] * t2[k][j];\r\n        }\r\n        if(j!=p-1)\r\n            d[row][col++]=sum;\r\n        else { //要换行了\r\n            d[row][col++]=sum;\r\n            row++;\r\n            col=0;\r\n        }\r\n    }\r\n}\r\nvoid calculate2(ll n, ll m, ll p, ll t1[105][105], ll t2[105][105]){\r\n    memset(e,0,sizeof e);\r\n    int row=0;//记录e矩阵到哪一行了\r\n    int col=0;//记录e矩阵到哪一列了\r\n    fo(i,0,n)fo(j,0,p){\r\n            ll sum=0;\r\n            fo(k,0,m){\r\n                sum+= 1LL * t1[i][k] * t2[k][j];\r\n            }\r\n            if(j!=p-1)\r\n                e[row][col++]=sum;\r\n            else { //要换行了\r\n                e[row][col++]=sum;\r\n                row++;\r\n                col=0;\r\n            }\r\n        }\r\n}\r\n//计算矩阵开心值\r\nll calculate3(ll n,ll m,ll t[105][105]){\r\n    ll sum=1;\r\n    fo(i,0,n)fo(j,0,m){\r\n        sum*=t[i][j];\r\n        sum%=mod;\r\n    }\r\n    return sum;\r\n}\r\nint main(){\r\n    int n1,m1,n2,m2,n3,m3;\r\n    //输入3个矩阵\r\n    cin>>n1>>m1;\r\n    fo(i,0,n1)fo(j,0,m1)scanf(\"%lld\",&a[i][j]);\r\n\r\n    cin>>n2>>m2;\r\n    fo(i,0,n2)fo(j,0,m2)scanf(\"%lld\",&b[i][j]);\r\n\r\n    cin>>n3>>m3;\r\n    fo(i,0,n3)fo(j,0,m3)scanf(\"%lld\",&c[i][j]);\r\n    //求6次开心值\r\n    //abc型([n1,m1] * [n2,m2] * [n3,m3])\r\n    if(m1==n2&&m2==n3){//存在开心值\r\n        calculate(n1,m1,m2,a,b);\r\n        calculate2(n1,m2,m3,d,c);\r\n        happy[0]=calculate3(n1,m3,e);\r\n    }\r\n    else happy[0]=-1;\r\n    //acb型([n1,m1] * [n3,m3] * [n2,m2])\r\n    if(m1==n3&&m3==n2){\r\n        calculate(n1,m1,m3,a,c);\r\n        calculate2(n1,m3,m2,d,b);\r\n        happy[1]=calculate3(n1,m2,e);\r\n    }\r\n    else happy[1]=-1;\r\n    //bac型([n2,m2] * [n1,m1] * [n3,m3])\r\n    if(m2==n1&&m1==n3){\r\n        calculate(n2,m2,m1,b,a);\r\n        calculate2(n2,m1,m3,d,c);\r\n        happy[2]=calculate3(n2,m3,e);\r\n    }\r\n    else happy[2]=-1;\r\n    //bca型([n2,m2] * [n3,m3] * [n1,m1])\r\n    if(m2==n3&&m3==n1){\r\n        calculate(n2,m2,m3,b,c);\r\n        calculate2(n2,m3,m1,d,a);\r\n        happy[3]=calculate3(n2,m1,e);\r\n    }\r\n    else happy[3]=-1;\r\n    //cab型([n3,m3] * [n1,m1] * [n2,m2])\r\n    if(m3==n1&&m1==n2){\r\n        calculate(n3,m3,m1,c,a);\r\n        calculate2(n3,m1,m2,d,b);\r\n        happy[4]=calculate3(n3,m2,e);\r\n    }\r\n    else happy[4]=-1;\r\n    //cba型([n3,m3] * [n2,m2] * [n1,m1])\r\n    if(m3==n2&&m2==n1){\r\n        calculate(n3,m3,m2,c,b);\r\n        calculate2(n3,m2,m1,d,a);\r\n        happy[5]=calculate3(n3,m1,e);\r\n    }\r\n    else happy[5]=-1;\r\n\r\n    ll mx=-1;\r\n    for (int i = 0; i < 6; ++i) {\r\n        mx=max(mx,happy[i]);\r\n    }\r\n    if(mx==-1)cout<<\"ERROR\";\r\n    else cout<<mx;\r\n    return 0;\r\n}\r\n```\r\n\r\n## [消费卷](https://ac.nowcoder.com/acm/contest/13545/M)\r\n\r\n**思路：**\r\n\r\n先跑一次spfa看能不能到终点，如果能，那就看距离是不是超过了cnt（这次spfa边权都是1），如果超过了，那就进入正题，我们可以二分最小花费cost，对于如何check，把这张图的边权映射为1或0（大于cost为1，反之为0），再跑spfa就可以了，如果最后终点的最短路小于等于cnt，check就返回true，反之返回false，二分正确是因为解是单调最优的，cost越大就越容易成功，cost越小就越难成功\r\n\r\n```c++\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nconst int N = 2e6 + 10;\r\nint n,m;\r\nint h[N],e[N],w[N],ne[N],idx;\r\nint S,T,num;\r\nint d[N];\r\nbool st[N];\r\nvoid spfa(){\r\n    memset(st,0,sizeof st);\r\n    queue<int> q;\r\n    q.push(S);\r\n    st[S] = 1;\r\n    while(q.size()){\r\n        int t = q.front();\r\n        q.pop();\r\n        for(int i = h[t];~i;i = ne[i]){\r\n            int j = e[i];\r\n            if(st[j]) continue;\r\n            st[j] = true;\r\n            d[j] = d[t] + 1;//权值设为1\r\n            q.push(j);\r\n        }\r\n    }\r\n}\r\nvoid add(int x,int y,int z){\r\n    ne[idx] = h[x],e[idx] = y,w[idx] = z,h[x] = idx++;\r\n}\r\nbool spfa2(int mid){\r\n    memset(st,0,sizeof st);\r\n    memset(d,0x3f,sizeof d);\r\n    d[S] = 0;\r\n    queue<int> q;\r\n    q.push(S);\r\n    while(q.size()){\r\n        int t = q.front();\r\n        q.pop();\r\n        st[t] = false;\r\n        for(int i = h[t];~i;i = ne[i]){\r\n            int j = e[i];\r\n            int p = w[i] > mid ? 1 : 0;\r\n            if(d[j] > d[t] + p){\r\n                d[j] = d[t] + p;\r\n                if(!st[j]){\r\n                    q.push(j);\r\n                    st[j] = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return d[T] <= num;\r\n}\r\nint main(){\r\n    memset(h,-1,sizeof h);\r\n    cin>>n>>m>>S>>T>>num;\r\n    while(m--){\r\n        int x,y,z;\r\n        cin>>x>>y>>z;\r\n        add(x,y,z),add(y,x,z);\r\n    }\r\n    spfa();\r\n    if(!st[T]){\r\n        puts(\"No\");\r\n        return 0;\r\n    }\r\n    puts(\"Yes\");\r\n    if(d[T] <= num){\r\n        puts(\"0\");\r\n        return 0;\r\n    }\r\n    int l = 0,r = 1e9;\r\n    while(l < r){\r\n        int mid = (l + r) >> 1;\r\n        if(spfa2(mid)) r = mid;\r\n        else l = mid + 1;\r\n    }\r\n    printf(\"%d\\n\",l);\r\n    return 0;\r\n}\r\n```\r\n\r\n## [排队](https://ac.nowcoder.com/acm/contest/13545/N)\r\n\r\n**思路：**\r\n\r\n贪心的去想，权值越大的越要在最靠边的位置上，那么我们把比较大的值放最右边还是最左边呢，这就需要   $dp$ 了，因此我们就去讨论放在左边多少个，右边多少个，然后状态转移， $f[i][j]$ 表示按从大到小的分配顺序，所有左边分配 $i$ 人，右边分配 $j$ 人的分配方式的最大值\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nint main(){\r\n    int n;\r\n    cin >> n;\r\n    vector<pair<int, int>> a(n);\r\n    ll f[n+1][n+1];\r\n    memset(f,0,sizeof f);\r\n    for (int i = 0; i < n; i++) {\r\n        cin >> a[i].first;\r\n        a[i].second = i + 1;\r\n    }\r\n    //按第一维从大到小排序\r\n    sort(a.rbegin(), a.rend());\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j <= i; j++) {\r\n            int k = i - j;\r\n            //放左边\r\n            f[j + 1][k] = max(f[j + 1][k], f[j][k] + 1ll * a[i].first * abs(a[i].second - (j + 1)));\r\n            //放右边\r\n            f[j][k + 1] = max(f[j][k + 1], f[j][k] + 1ll * a[i].first * abs(n - k - a[i].second));\r\n        }\r\n    }\r\n    ll ans = 0;\r\n    for (int i = 0; i <= n; i++) ans = max(ans, f[i][n - i]);\r\n    cout << ans << \'\\n\';\r\n    return 0;\r\n}\r\n```\r\n\r\n', 'http://5b0988e595225.cdn.sohucs.com/images/20190112/12a825d7c0f94223a0b1fc3dcddc6570.jpeg', '原创', 0, 1, 1, 1, 1, 1, '2022-09-07 16:19:41', '2022-09-07 16:19:41', 2, 1, '石家庄铁道大学2021年天梯赛选拔赛题解', '7');

-- ----------------------------
-- Table structure for t_blog_tags
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tags`;
CREATE TABLE `t_blog_tags`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_id` bigint(20) NULL DEFAULT NULL,
  `blog_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_blog_tags
-- ----------------------------
INSERT INTO `t_blog_tags` VALUES (1, 1, '1');
INSERT INTO `t_blog_tags` VALUES (2, 1, '2');
INSERT INTO `t_blog_tags` VALUES (3, 1, '3');
INSERT INTO `t_blog_tags` VALUES (4, 1, '4');
INSERT INTO `t_blog_tags` VALUES (5, 6, '5');
INSERT INTO `t_blog_tags` VALUES (6, 4, '6');
INSERT INTO `t_blog_tags` VALUES (7, 4, '7');
INSERT INTO `t_blog_tags` VALUES (8, 3, '3');

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT NULL,
  `blog_id` bigint(20) NULL DEFAULT NULL,
  `parent_comment_id` bigint(20) NULL DEFAULT NULL,
  `admincomment` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (1, '小白', 'bai@qq.com', '小白的评论', '/images/avatar.jpg', '2020-03-15 21:28:13', 4, -1, NULL);
INSERT INTO `t_comment` VALUES (2, '小红', 'hong@qq.com', '小红的评论', '/images/avatar.jpg', '2020-03-15 21:35:02', 4, -1, NULL);
INSERT INTO `t_comment` VALUES (5, '小蓝', 'lan@qq.com', '小蓝的评论', '/images/avatar.jpg', '2020-03-16 15:04:24', 4, -1, NULL);
INSERT INTO `t_comment` VALUES (7, '小绿', 'lv@qq.com', '小绿的评论', 'http://5b0988e595225.cdn.sohucs.com/images/20181103/feaa7d14883047fb81bbaa16f681f583.jpeg', '2020-03-16 15:11:07', 2, -1, 1);
INSERT INTO `t_comment` VALUES (8, '小天', '2333@qq.com', '不论是我的世界车水马龙繁华盛世 还是它们都瞬间消失化为须臾 我都会坚定地走向你 不慌张 不犹豫', '/images/avatar.jpg', '2020-03-24 17:41:17', 1, -1, 0);

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (1, '前端');
INSERT INTO `t_tag` VALUES (2, '后端');
INSERT INTO `t_tag` VALUES (3, 'springboot');
INSERT INTO `t_tag` VALUES (4, 'c++');
INSERT INTO `t_tag` VALUES (5, '杂谈');
INSERT INTO `t_tag` VALUES (6, 'java');

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES (1, '框架学习');
INSERT INTO `t_type` VALUES (2, '算法题解');
INSERT INTO `t_type` VALUES (3, '知识积累');

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type` int(10) NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (1, '小铁', '小铁', 'e10adc3949ba59abbe56e057f20f883e', '691639910@qq.com', 'https://pic.imgdb.cn/item/60f59dd75132923bf8720485.png', 1, '2022-09-04 18:25:26', NULL);

SET FOREIGN_KEY_CHECKS = 1;
